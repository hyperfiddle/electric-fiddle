# Internal tools and Electric Clojure, Part 2 <span id="title-extra"><span>

*by Dustin Getz, 2025 Jan 9*

<style>
.Tutorial .user-examples-code { max-height: 50em; }
.Tutorial > .Browser { position: relative; height: 45em; }
.Tutorial > .Browser fieldset.entity,
.Tutorial > .Browser fieldset.entity-children,
.Tutorial > .Browser fieldset.entity-meta,
.Tutorial > .Browser fieldset.entity-meta-children { position:absolute; }
</style>

This is the second part of a two-part post about building tools with Electric Clojure. Earlier this week in [Internal Tools and Electric Clojure, Part 1](/blog/y20250106_threaddump_part1) I described how in **31 lines of code and 20 minutes** I built a thread dumper utility. At the end I wondered aloud, **how long it would take to get a proper clojure.datify data browser view,** so we could get better thread observability in a more structured way than mashing strings together?

So, it's now three days later, let's take a look at the progress! Here it is:

<div style="margin-bottom: 2em;"></div>

!target-nochrome[docs-site.blog.threaddump2/ThreadDump2]()

<div style="margin-bottom: 2em;"></div>

What's happening

* General EDN viewer utility
* select a target object - I gave you a jvm thread interface, a git repo, and two classes
* top panel displays target object as a nested document
* hover the unqualified attribute names to see their namespace
* it contains hyperlinks marked `...`, e.g. the git log, click them! 
* hyperlinks open in the bottom panel - a table view with dynamic column picker. In the git log, try removing all columns except `author`, `id`, `message`

We're definitely not finished with our goal of "structured thread browser UI", but it's still an interesting checkpoint in the journey.

As before, we want to understand: 
* how many lines of code do you think?
* how many hours to build do you think?

## Code

Here is the entrypoint with target picker, **29 LOC** (one third of which is the namespace definition):

!ns-src[docs-site.blog.threaddump2]()

Here's the datafy-jvm implementation, **27 LOC**

!ns-src[dustingetz.datafy-jvm]()

Here's the [two pane EdnViewer code](https://gist.github.com/dustingetz/5f089be0e3dc66c13b2e57b4349f47ed), as a gist because at **99 LOC** is a bit too long to embed here. For completeness, this gist has two notable dependencies: 
1. `dustingetz.easy-table/TableScroll` from Part 1, and 
2. `dustingetz.flatten-document/flatten-nested`, a throwaway Claude fn (attached also in the gist).

That's everything, there are **no other namespaces with secret code that I am hiding,** this is literally it.

## Time cost

Things I spent time on:

* getting tooltip css to work inside our virtual scroll strategy
* refactoring this blog app
* refactoring the demo css to be compatible with this blog layout
* futzing around with clojure resource path to get these src embeds to work reliably (btw, that's just `(CodeMirror ... (e/server (some-> ns-sym find-ns meta :file io/resource)))` cuz the server can just read resources, see? The futzing is because it turns out those metas are unreliable, so i had to debug that)
* figuring out the java thread management APIs
* refactoring my custom markdown extensions that power these essays, i.e. dealing with my own busted/experimental designs (I have so many of them because with Electric they are so cheap to make!)

And of course, writing this actual essay content, which took about 5 hours - probably one third of the total time. 

Things that just worked:

* refactoring EdnView (which I made on Dec 28th ([tweet](https://x.com/dustingetz/status/1873104286999298352)), 13 days ago)
* configuring virtual scroll tables
* rendering class metadata in the EDN view
* building clojure.datafy wrapper for java thread APIs once I understood them
* trying a 4-pane browser view (so I can see the class metadata while building datafy wrappers),then  switching back to 2-pane once finished, for mobile friendly layout
* encoding hyperlinks as server-side methods/functions and rendering them appropriately
* object target picker - giving you multiple datafy instances to play with
* changing `electric-forms0/Checkbox` to support `:type "radio"` and hacking together an inline radio group
* implementing a row-select functionality (scroll up again, try selecting a row!) - which I ended up not using yet

What's missing to finish our internal tool from Part 1?

* object navigation - navigate from management API, to list of threads, to a single thread, to its stack trace (or whatever) if deadlocked 
* using class metadata to drive view structure would be interesting

As you can see we have all the primitives and components, the performance is good, the table is good, the code is expressive and tight. The problem with this app is not the code, it's the product design, it doesn't quite solve the problem yet. 

Let me restate that: ** *With Electric, the bottleneck is no longer the coding of the implementation, it is the product design.* ** Let that sink in.

## Conclusion

This blog series has a time axis. Part 1 was written on Monday the 6th, and today I write part 2 on Thursday the 9th, three days later. By the way, I did not work on this full time, I am currently working on three separate deals and have been spending my mornings writing memos to attorneys and generally feeling very stressed. This is the fun thing in my day, that I look forward to after the real work is done!

And Electric Clojure has brought it within my reach to run little experiments like this, cheaply enough to fit in the cracks of my week.

What would it be like, if your business could afford to run product experiments, to try ideas, to change features, and have the **cost of these experiments be so low that you can just try things, in the moment you think of them?** What if you could build systems and not be limited by the debugging and the planning and the refactoring and the tech debt, but instead **actualize your ideas, as fast as you can think them?**

Are you getting it?

Check out [the Electric tutorial here](https://electric.hyperfiddle.net/tutorial/), and [sign up for beta access here](https://www.hyperfiddle.net/early-access.html), we are expanding the beta rapidly.

Part 3 will be about implementing the actual thread browser, with navigation. I have some design work to do :) See you next week!