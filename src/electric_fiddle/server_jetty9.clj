(ns electric-fiddle.server-jetty9
  (:require [clojure.java.io :as io]
            [hyperfiddle.electric-jetty9-ring-adapter :as electric-adapter]
            [clojure.tools.logging :as log]
            [ring.adapter.jetty :as ring]
            [ring.middleware.basic-authentication :as auth]
            [ring.middleware.content-type :refer [wrap-content-type]]
            [ring.middleware.cookies :as cookies]
            [ring.middleware.params :refer [wrap-params]]
            [ring.middleware.resource :refer [wrap-resource]]
            [ring.middleware.not-modified :refer [wrap-not-modified]]
            [ring.util.response :as res]
            [clojure.string :as str]
            [clojure.edn :as edn])
  (:import [java.io IOException]
           [java.net BindException]
           [org.eclipse.jetty.server.handler.gzip GzipHandler]))

(defn authenticate [username password] username) ; demo (accept-all) authentication

(defn wrap-demo-authentication "A Basic Auth example. Accepts any username/password and store the username in a cookie."
  [next-handler]
  (-> (fn [ring-req]
        (let [res (next-handler ring-req)]
          (if-let [username (:basic-authentication ring-req)]
            (res/set-cookie res "username" username {:http-only true})
            res)))
    (cookies/wrap-cookies)
    (auth/wrap-basic-authentication authenticate)))

(defn wrap-add-basic-authentication-key [next-handler]
  (fn [ring-req]
    (next-handler (auth/basic-authentication-request ring-req authenticate))))

(defn wrap-demo-router "A basic path-based routing middleware"
  [next-handler]
  (fn [ring-req]
    (case (:uri ring-req)
      "/auth" (let [response  ((wrap-demo-authentication next-handler) ring-req)]
                (if (= 401 (:status response)) ; authenticated?
                  response                     ; send response to trigger auth prompt
                  (-> (res/status response 302) ; redirect
                    (res/header "Location" (get-in ring-req [:headers "referer"]))))) ; redirect to where the auth originated
      ;; For any other route, delegate to next middleware
      (next-handler ring-req))))

(defn template "Takes a `string` and a map of key-values `kvs`. Replace all instances of `$key$` by value in `string`"
  [string kvs]
  (reduce-kv (fn [r k v] (str/replace r (str "$" k "$") v)) string kvs))

(defn get-modules [manifest-path]
  (when-let [manifest (io/resource manifest-path)]
    (let [manifest-folder (when-let [folder-name (second (rseq (str/split manifest-path #"\/")))]
                            (str "/" folder-name "/"))]
      (->> (slurp manifest)
        (edn/read-string)
        (reduce (fn [r module] (assoc r (keyword "hyperfiddle.client.module" (name (:name module))) (str manifest-folder (:output-name module)))) {})))))

(defn wrap-index-page
  "Server the `index.html` file with injected javascript modules from `manifest.edn`. `manifest.edn` is generated by the client build and contains javascript modules information."
  [next-handler resources-path manifest-path]
  (fn [ring-req]
    (if-let [response (res/resource-response (str resources-path "/index.html"))]
      (if-let [modules (get-modules manifest-path)]
        (-> (res/response (template (slurp (:body response)) modules)) ; TODO cache in prod mode
          (res/content-type "text/html")
          (res/header "Last-Modified" (get-in response [:headers "Last-Modified"])))
        ;; No manifest found, can't inject js modules
        (-> (res/not-found "Missing client program manifest")
          (res/content-type "text/plain")))
      ;; index.html file not found on classpath
      (next-handler ring-req))))

(def VERSION (not-empty (System/getProperty "ELECTRIC_USER_VERSION"))) ; see Dockerfile

(defn wrap-reject-stale-client
  "Intercept websocket UPGRADE request and check if client and server versions matches.
  An electric client is allowed to connect if its version matches the server's version, or if the server doesn't have a version set (dev mode).
  Otherwise, the client connection is rejected gracefully."
  [next-handler]
  (fn [ring-req]
    (let [client-version (get-in ring-req [:query-params "ELECTRIC_USER_VERSION"])]
      (cond
        (nil? VERSION)             (next-handler ring-req)
        (= client-version VERSION) (next-handler ring-req)
        :else (electric-adapter/reject-websocket-handler 1008 "stale client") ; https://www.rfc-editor.org/rfc/rfc6455#section-7.4.1
        ))))

(def wrap-websocket-middleware
  (fn [next-handler]
    (-> (cookies/wrap-cookies next-handler) ; makes cookies available to Electric app
      (wrap-reject-stale-client)
      (wrap-params)
      (wrap-add-basic-authentication-key))))

(defn not-found-handler [_ring-request]
  (-> (res/not-found "Not found")
    (res/content-type "text/plain")))

(defn wrap-always-revalidate [next-handler]
  ;; https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Cache-Control#up-to-date_contents_always
  (fn [ring-req]
    (assoc-in (next-handler ring-req) [:headers "Cache-Control"]
      ;; no-cache doesn't mean don't cache but rather "always revalidate".
      ;; must-revalidate ensures all intermediate caches (not just proxies) will revalidate.
      "no-cache, must-revalidate"))) ; no-cache doesn't mean don't cache!

(defn http-middleware [resources-path manifest-path]
  ;; these compose as functions, so are applied bottom up
  (-> not-found-handler
    (wrap-index-page resources-path manifest-path) ; 5. otherwise fallback to default page file
    (wrap-resource resources-path) ; 4. serve static file from classpath
    (wrap-always-revalidate)
    (wrap-not-modified) ; 3. ensure cached resources are re-validated
    (wrap-content-type) ; 2. detect content (e.g. for index.html)
    (wrap-demo-router) ; 1. route
    ))

(defn- add-gzip-handler
  "Makes Jetty server compress responses. Optional but recommended."
  [server]
  (.setHandler server
    (doto (GzipHandler.)
      #_(.setIncludedMimeTypes (into-array ["text/css" "text/plain" "text/javascript" "application/javascript" "application/json" "image/svg+xml"])) ; only compress these
      (.setMinGzipSize 1024)
      (.setHandler (.getHandler server)))))

(defn start-server! [entrypoint {:keys [port resources-path manifest-path]
                                 :or {port 8080
                                      resources-path "public"
                                      manifest-path "public/js/manifest.edn"}
                                 :as config}]
  (try
    (let [server (ring/run-jetty (http-middleware resources-path manifest-path)
                   (merge {:port port
                           :join? false
                           :configurator (fn [server]
                                           (electric-adapter/electric-jetty9-ws-install server "/" entrypoint wrap-websocket-middleware)
                                           (add-gzip-handler server))}
                     config))
          final-port (-> server (.getConnectors) first (.getPort))]
      (println "\nðŸ‘‰ App server available at" (str "http://" (:host config) ":" final-port "\n"))
      server)

    (catch IOException err
      (if (instance? BindException (ex-cause err))  ; port is already taken, retry with another one
        (do (log/warn "Port" port "was not available, retrying with" (inc port))
            (start-server! entrypoint (update config :port inc)))
        (throw err)))))
